// Package persistence provides repository implementations for Orderitem entity.
//
// Generated by TelemetryFlow RESTful API Generator
// Copyright (c) 2024-2026 DevOpsCorner Indonesia. All rights reserved.
package persistence

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/google/uuid"
	"github.com/telemetryflow/order-service/internal/domain/entity"
	"github.com/telemetryflow/order-service/internal/domain/repository"
)

// orderitemRepository implements repository.OrderitemRepository
type orderitemRepository struct {
	db *sql.DB
}

// NewOrderitemRepository creates a new Orderitem repository
func NewOrderitemRepository(db *sql.DB) repository.OrderitemRepository {
	return &orderitemRepository{
		db: db,
	}
}

// Create creates a new orderitem
func (r *orderitemRepository) Create(ctx context.Context, orderitem *entity.Orderitem) error {
	query := `
		INSERT INTO order_items (
			id, order_id, product_id, quantity, price, created_at, updated_at
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7
		)`

	_, err := r.db.ExecContext(ctx, query,
		orderitem.ID,
		orderitem.OrderId,
		orderitem.ProductId,
		orderitem.Quantity,
		orderitem.Price,
		orderitem.CreatedAt,
		orderitem.UpdatedAt,
	)
	return err
}

// FindByID retrieves an orderitem by ID
func (r *orderitemRepository) FindByID(ctx context.Context, id uuid.UUID) (*entity.Orderitem, error) {
	query := `
		SELECT id, order_id, product_id, quantity, price, created_at, updated_at
		FROM order_items
		WHERE id = $1 AND deleted_at IS NULL`

	row := r.db.QueryRowContext(ctx, query, id)

	orderitem := &entity.Orderitem{}
	err := row.Scan(
		&orderitem.ID,
		&orderitem.OrderId,
		&orderitem.ProductId,
		&orderitem.Quantity,
		&orderitem.Price,
		&orderitem.CreatedAt,
		&orderitem.UpdatedAt,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("orderitem not found")
		}
		return nil, err
	}

	return orderitem, nil
}

// FindAll retrieves all orderitems with pagination
func (r *orderitemRepository) FindAll(ctx context.Context, offset, limit int) ([]entity.Orderitem, int64, error) {
	// Count total records
	countQuery := "SELECT COUNT(*) FROM order_items WHERE deleted_at IS NULL"
	var total int64
	err := r.db.QueryRowContext(ctx, countQuery).Scan(&total)
	if err != nil {
		return nil, 0, err
	}

	// Get paginated records
	query := `
		SELECT id, order_id, product_id, quantity, price, created_at, updated_at
		FROM order_items
		WHERE deleted_at IS NULL
		ORDER BY created_at DESC
		LIMIT $1 OFFSET $2`

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	var orderitems []entity.Orderitem
	for rows.Next() {
		var orderitem entity.Orderitem
		err := rows.Scan(
			&orderitem.ID,
			&orderitem.OrderId,
			&orderitem.ProductId,
			&orderitem.Quantity,
			&orderitem.Price,
			&orderitem.CreatedAt,
			&orderitem.UpdatedAt,
		)
		if err != nil {
			return nil, 0, err
		}
		orderitems = append(orderitems, orderitem)
	}

	return orderitems, total, nil
}

// Update updates an orderitem
func (r *orderitemRepository) Update(ctx context.Context, orderitem *entity.Orderitem) error {
	query := `
		UPDATE order_items
		SET order_id = $1, product_id = $2, quantity = $3, price = $4, updated_at = $5
		WHERE id = $6 AND deleted_at IS NULL`

	_, err := r.db.ExecContext(ctx, query,
		orderitem.OrderId,
		orderitem.ProductId,
		orderitem.Quantity,
		orderitem.Price,
		orderitem.UpdatedAt,
		orderitem.ID,
	)
	return err
}

// Delete soft-deletes an orderitem by ID
func (r *orderitemRepository) Delete(ctx context.Context, id uuid.UUID) error {
	query := "UPDATE order_items SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

// HardDelete permanently deletes an orderitem by ID
func (r *orderitemRepository) HardDelete(ctx context.Context, id uuid.UUID) error {
	query := "DELETE FROM order_items WHERE id = $1"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}
