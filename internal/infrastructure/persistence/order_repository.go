// Package persistence provides repository implementations for Order entity.
//
// Generated by TelemetryFlow RESTful API Generator
// Copyright (c) 2024-2026 DevOpsCorner Indonesia. All rights reserved.
package persistence

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/google/uuid"
	"github.com/telemetryflow/order-service/internal/domain/entity"
	"github.com/telemetryflow/order-service/internal/domain/repository"
)

// orderRepository implements repository.OrderRepository
type orderRepository struct {
	db *sql.DB
}

// NewOrderRepository creates a new Order repository
func NewOrderRepository(db *sql.DB) repository.OrderRepository {
	return &orderRepository{
		db: db,
	}
}

// Create creates a new order
func (r *orderRepository) Create(ctx context.Context, order *entity.Order) error {
	query := `
		INSERT INTO orders (
			id, customer_id, total, status, created_at, updated_at
		) VALUES (
			$1, $2, $3, $4, $5, $6
		)`

	_, err := r.db.ExecContext(ctx, query,
		order.ID,
		order.CustomerId,
		order.Total,
		order.Status,
		order.CreatedAt,
		order.UpdatedAt,
	)
	return err
}

// FindByID retrieves an order by ID
func (r *orderRepository) FindByID(ctx context.Context, id uuid.UUID) (*entity.Order, error) {
	query := `
		SELECT id, customer_id, total, status, created_at, updated_at
		FROM orders
		WHERE id = $1 AND deleted_at IS NULL`

	row := r.db.QueryRowContext(ctx, query, id)

	order := &entity.Order{}
	err := row.Scan(
		&order.ID,
		&order.CustomerId,
		&order.Total,
		&order.Status,
		&order.CreatedAt,
		&order.UpdatedAt,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("order not found")
		}
		return nil, err
	}

	return order, nil
}

// FindAll retrieves all orders with pagination
func (r *orderRepository) FindAll(ctx context.Context, offset, limit int) ([]entity.Order, int64, error) {
	// Count total records
	countQuery := "SELECT COUNT(*) FROM orders WHERE deleted_at IS NULL"
	var total int64
	err := r.db.QueryRowContext(ctx, countQuery).Scan(&total)
	if err != nil {
		return nil, 0, err
	}

	// Get paginated records
	query := `
		SELECT id, customer_id, total, status, created_at, updated_at
		FROM orders
		WHERE deleted_at IS NULL
		ORDER BY created_at DESC
		LIMIT $1 OFFSET $2`

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	var orders []entity.Order
	for rows.Next() {
		var order entity.Order
		err := rows.Scan(
			&order.ID,
			&order.CustomerId,
			&order.Total,
			&order.Status,
			&order.CreatedAt,
			&order.UpdatedAt,
		)
		if err != nil {
			return nil, 0, err
		}
		orders = append(orders, order)
	}

	return orders, total, nil
}

// Update updates an order
func (r *orderRepository) Update(ctx context.Context, order *entity.Order) error {
	query := `
		UPDATE orders
		SET customer_id = $1, total = $2, status = $3, updated_at = $4
		WHERE id = $5 AND deleted_at IS NULL`

	_, err := r.db.ExecContext(ctx, query,
		order.CustomerId,
		order.Total,
		order.Status,
		order.UpdatedAt,
		order.ID,
	)
	return err
}

// Delete soft-deletes an order by ID
func (r *orderRepository) Delete(ctx context.Context, id uuid.UUID) error {
	query := "UPDATE orders SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

// HardDelete permanently deletes an order by ID
func (r *orderRepository) HardDelete(ctx context.Context, id uuid.UUID) error {
	query := "DELETE FROM orders WHERE id = $1"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

// FindByStatus finds orders by status
func (r *orderRepository) FindByStatus(ctx context.Context, status string) ([]entity.Order, error) {
	query := `
		SELECT id, customer_id, total, status, created_at, updated_at
		FROM orders
		WHERE status = $1 AND deleted_at IS NULL
		ORDER BY created_at DESC`

	rows, err := r.db.QueryContext(ctx, query, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var orders []entity.Order
	for rows.Next() {
		var order entity.Order
		err := rows.Scan(
			&order.ID,
			&order.CustomerId,
			&order.Total,
			&order.Status,
			&order.CreatedAt,
			&order.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		orders = append(orders, order)
	}

	return orders, nil
}
